{
  "version": 3,
  "sources": ["../src/internal/toInternalBytes.ts", "../src/internal/mergeUint8.ts", "../src/internal/mapObject.ts", "../src/utils.ts", "../src/codecs/fixed-width-ints.ts", "../src/codecs/bool.ts", "../src/codecs/compact.ts", "../src/codecs/str.ts", "../src/codecs/void.ts", "../src/codecs/Bytes.ts", "../src/codecs/Enum.ts", "../src/codecs/Option.ts", "../src/codecs/Result.ts", "../src/codecs/Tuple.ts", "../src/codecs/Struct.ts", "../src/codecs/Vector.ts"],
  "sourcesContent": ["import { Decoder } from \"../types\"\n\n// https://jsben.ch/URe1X\nconst HEX_MAP: Record<string, number> = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15,\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15,\n}\nexport function fromHex(hexString: string): Uint8Array {\n  const isOdd = hexString.length % 2\n  /* istanbul ignore next */\n  const base = (hexString[1] === \"x\" ? 2 : 0) + isOdd\n  const nBytes = (hexString.length - base) / 2 + isOdd\n  const bytes = new Uint8Array(nBytes)\n\n  if (isOdd) bytes[0] = 0 | HEX_MAP[hexString[2]]\n\n  for (let i = 0; i < nBytes; ) {\n    const idx = base + i * 2\n    const a = HEX_MAP[hexString[idx]]\n    const b = HEX_MAP[hexString[idx + 1]]\n    bytes[isOdd + i++] = (a << 4) | b\n  }\n\n  return bytes\n}\n\nclass InternalUint8Array extends Uint8Array {\n  i: number = 0\n  v: DataView\n\n  constructor(buffer: ArrayBuffer) {\n    super(buffer)\n    this.v = new DataView(buffer)\n  }\n}\n\nexport const toInternalBytes =\n  <T>(fn: (input: InternalUint8Array) => T): Decoder<T> =>\n  (buffer: string | ArrayBuffer | Uint8Array | InternalUint8Array) =>\n    fn(\n      buffer instanceof InternalUint8Array\n        ? buffer\n        : new InternalUint8Array(\n            buffer instanceof Uint8Array\n              ? buffer.buffer\n              : typeof buffer === \"string\"\n              ? fromHex(buffer).buffer\n              : buffer,\n          ),\n    )\n", "export const mergeUint8 = (inputs: Array<Uint8Array>): Uint8Array => {\n  const len = inputs.length\n  let totalLen = 0\n  for (let i = 0; i < len; i++) totalLen += inputs[i].length\n  const result = new Uint8Array(totalLen)\n\n  for (let idx = 0, at = 0; idx < len; idx++) {\n    const current = inputs[idx]\n    result.set(current, at)\n    at += current.byteLength\n  }\n\n  return result\n}\n", "export function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k: K) => O,\n): Record<K, O>\n\nexport function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k?: K) => O,\n): Record<K, O> {\n  const keys = Object.keys(input) as Array<K>\n  const len = keys.length\n\n  const result: Record<K, O> = {} as any\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    result[key] = mapper(input[key], key)\n  }\n\n  return result\n}\n", "import type { Codec, Decoder, Encoder } from \"./types\"\nimport { toInternalBytes } from \"./internal\"\n\nexport const createDecoder: <T>(fn: (input: Uint8Array) => T) => Decoder<T> =\n  toInternalBytes as any\n\nexport const createCodec = <T>(\n  encoder: Encoder<T>,\n  decoder: Decoder<T>,\n): Codec<T> => {\n  const result = [encoder, decoder] as any\n  result.enc = encoder\n  result.dec = decoder\n  return result\n}\n\nexport const enhanceEncoder =\n  <I, O>(encoder: Encoder<I>, mapper: (value: O) => I): Encoder<O> =>\n  (value) =>\n    encoder(mapper(value))\n\nexport const enhanceDecoder =\n  <I, O>(decoder: Decoder<I>, mapper: (value: I) => O): Decoder<O> =>\n  (value) =>\n    mapper(decoder(value))\n\nexport const enhanceCodec = <I, O>(\n  [encoder, decoder]: Codec<I>,\n  toFrom: (value: O) => I,\n  fromTo: (value: I) => O,\n): Codec<O> =>\n  createCodec(enhanceEncoder(encoder, toFrom), enhanceDecoder(decoder, fromTo))\n", "import { createCodec } from \"../utils\"\nimport { Codec, Decoder, Encoder } from \"../types\"\nimport { toInternalBytes } from \"../internal\"\n\nfunction decodeInt(nBytes: 8, getter: keyof DataView): Decoder<bigint>\nfunction decodeInt(nBytes: number, getter: keyof DataView): Decoder<number>\nfunction decodeInt(\n  nBytes: number,\n  getter: keyof DataView,\n): Decoder<number> | Decoder<bigint> {\n  return toInternalBytes((bytes) => {\n    const result = (bytes.v[getter] as any)(bytes.i, true) as number\n    bytes.i += nBytes\n    return result\n  })\n}\n\nfunction encodeInt(nBytes: 8, setter: keyof DataView): Encoder<bigint>\nfunction encodeInt(nBytes: number, setter: keyof DataView): Encoder<number>\nfunction encodeInt(\n  nBytes: number,\n  setter: keyof DataView,\n): Encoder<number> | Encoder<bigint> {\n  return (input: number | bigint) => {\n    const result = new Uint8Array(nBytes)\n    const dv = new DataView(result.buffer)\n    ;(dv[setter] as any)(0, input, true)\n    return result\n  }\n}\n\nfunction intCodec(\n  nBytes: 8,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<bigint>\nfunction intCodec(\n  nBytes: number,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<number>\nfunction intCodec(\n  nBytes: number,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<bigint> | Codec<number> {\n  return createCodec(encodeInt(nBytes, setter), decodeInt(nBytes, getter))\n}\n\nexport const u8 = intCodec(1, \"getUint8\", \"setUint8\")\nexport const u16 = intCodec(2, \"getUint16\", \"setUint16\")\nexport const u32 = intCodec(4, \"getUint32\", \"setUint32\")\nexport const u64 = intCodec(8, \"getBigUint64\", \"setBigUint64\")\nexport const i8 = intCodec(1, \"getInt8\", \"setInt8\")\nexport const i16 = intCodec(2, \"getInt16\", \"setInt16\")\nexport const i32 = intCodec(4, \"getInt32\", \"setInt32\")\nexport const i64 = intCodec(8, \"getBigInt64\", \"setBigInt64\")\n\nconst x128Enc: Encoder<bigint> = (value) => {\n  const result = new Uint8Array(16)\n  const dv = new DataView(result.buffer)\n  dv.setBigInt64(0, value, true)\n  dv.setBigInt64(8, value >> 64n, true)\n  return result\n}\n\nconst create128Dec = (\n  method: \"getBigInt64\" | \"getBigUint64\",\n): Decoder<bigint> =>\n  toInternalBytes((input) => {\n    const { v, i } = input\n    const right = v.getBigUint64(i, true)\n    const left = v[method](i + 8, true)\n    input.i += 16\n    return (left << 64n) | right\n  })\n\nexport const u128 = createCodec(x128Enc, create128Dec(\"getBigUint64\"))\nexport const i128 = createCodec(x128Enc, create128Dec(\"getBigInt64\"))\n\nconst x256Enc: Encoder<bigint> = (value) => {\n  const result = new Uint8Array(32)\n  const dv = new DataView(result.buffer)\n  dv.setBigInt64(0, value, true)\n  dv.setBigInt64(8, value >> 64n, true)\n  dv.setBigInt64(16, value >> 128n, true)\n  dv.setBigInt64(24, value >> 192n, true)\n  return result\n}\n\nconst create256Dec = (\n  method: \"getBigInt64\" | \"getBigUint64\",\n): Decoder<bigint> =>\n  toInternalBytes((input) => {\n    let result = input.v.getBigUint64(input.i, true)\n    input.i += 8\n\n    result |= input.v.getBigUint64(input.i, true) << 64n\n    input.i += 8\n\n    result |= input.v.getBigUint64(input.i, true) << 128n\n    input.i += 8\n\n    result |= input.v[method](input.i, true) << 192n\n    input.i += 8\n\n    return result\n  })\nexport const u256 = createCodec(x256Enc, create256Dec(\"getBigUint64\"))\nexport const i256 = createCodec(x256Enc, create256Dec(\"getBigInt64\"))\n", "import { Codec } from \"../types\"\nimport { enhanceCodec } from \"../\"\nimport { u8 } from \"./fixed-width-ints\"\n\nexport const bool: Codec<boolean> = enhanceCodec(\n  u8,\n  (value: boolean) => (value ? 1 : 0),\n  Boolean,\n)\n", "import { createCodec } from \"../\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { u8, u16, u32, u64 } from \"./fixed-width-ints\"\nimport { Decoder, Encoder, Codec } from \"../types\"\n\nconst decoders = [u8[1], u16[1], u32[1]] as const\nconst compactDec: Decoder<number | bigint> = toInternalBytes<number | bigint>(\n  (bytes) => {\n    const init = bytes[bytes.i]\n\n    const kind = init & 3\n    if (kind < 3) return decoders[kind](bytes) >>> 2\n\n    const nBytes = (init >>> 2) + 4\n    bytes.i++\n\n    let result = 0n\n\n    const nU64 = (nBytes / 8) | 0\n    let shift = 0n\n    for (let i = 0; i < nU64; i++) {\n      result = (u64[1](bytes) << shift) | result\n      shift += 64n\n    }\n\n    let nReminders = nBytes % 8\n    if (nReminders > 3) {\n      result = (BigInt(u32[1](bytes)) << shift) | result\n      shift += 32n\n      nReminders -= 4\n    }\n\n    if (nReminders > 1) {\n      result = (BigInt(u16[1](bytes)) << shift) | result\n      shift += 16n\n      nReminders -= 2\n    }\n\n    if (nReminders) result = (BigInt(u8[1](bytes)) << shift) | result\n\n    return result\n  },\n)\n\nconst MIN_U64 = 1n << 56n\nconst MIN_U32 = 1 << 24\nconst MIN_U16 = 256\nconst U32_MASK = 4294967295n\n\nconst SINGLE_BYTE_MODE_LIMIT = 1 << 6\nconst TWO_BYTE_MODE_LIMIT = 1 << 14\nconst FOUR_BYTE_MODE_LIMIT = 1 << 30\n\nconst compactEnc: Encoder<number | bigint> = (input) => {\n  if (input < 0) throw new Error(`Wrong compact input (${input})`)\n\n  const nInput = Number(input) << 2\n  if (input < SINGLE_BYTE_MODE_LIMIT) return u8[0](nInput)\n  if (input < TWO_BYTE_MODE_LIMIT) return u16[0](nInput | 1)\n  if (input < FOUR_BYTE_MODE_LIMIT) return u32[0](nInput | 2)\n\n  let buffers: Array<Uint8Array> = [new Uint8Array(1)]\n  let bigValue = BigInt(input)\n  while (bigValue >= MIN_U64) {\n    buffers.push(u64[0](bigValue))\n    bigValue >>= 64n\n  }\n\n  if (bigValue >= MIN_U32) {\n    buffers.push(u32[0](Number(bigValue & U32_MASK)))\n    bigValue >>= 32n\n  }\n\n  let smValue = Number(bigValue)\n  if (smValue >= MIN_U16) {\n    buffers.push(u16[0](smValue))\n    smValue >>= 16\n  }\n\n  smValue && buffers.push(u8[0](smValue))\n\n  const result = mergeUint8(buffers)\n  result[0] = ((result.length - 5) << 2) | 3\n\n  return result\n}\n\nexport const compact: Codec<number | bigint> = createCodec(\n  compactEnc,\n  compactDec,\n)\n", "import { createCodec, Decoder, Encoder } from \"../\"\nimport { toInternalBytes, mergeUint8 } from \"../internal\"\nimport { compact } from \"./compact\"\n\nconst textEncoder = new TextEncoder()\nconst strEnc: Encoder<string> = (str) => {\n  const val = textEncoder.encode(str)\n  return mergeUint8([compact.enc(val.length), val])\n}\n\nconst textDecoder = new TextDecoder()\nconst strDec: Decoder<string> = toInternalBytes((bytes) => {\n  let nElements = compact.dec(bytes) as number\n  const dv = new DataView(bytes.buffer, bytes.i, nElements)\n  bytes.i += nElements\n  return textDecoder.decode(dv)\n})\n\nexport const str = createCodec(strEnc, strDec)\n", "import { Codec } from \"../types\"\nimport { createCodec } from \"../\"\n\nconst noop = (() => {}) as () => undefined\nconst emptyArr = new Uint8Array(0)\nexport const _void: Codec<undefined> = createCodec(() => emptyArr, noop)\n", "import { Encoder, Decoder, Codec } from \"../types\"\nimport { createCodec } from \"../\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { compact } from \"./compact\"\n\nconst BytesEnc = (nBytes?: number): Encoder<Uint8Array> =>\n  nBytes === undefined\n    ? (bytes) => mergeUint8([compact.enc(bytes.length), bytes])\n    : (bytes) => (bytes.length === nBytes ? bytes : bytes.slice(0, nBytes))\n\nconst BytesDec = (nBytes?: number): Decoder<Uint8Array> =>\n  toInternalBytes((bytes) => {\n    const len =\n      nBytes === undefined\n        ? (compact.dec(bytes) as number)\n        : nBytes !== Infinity\n        ? nBytes\n        : bytes.byteLength - bytes.i\n\n    const result = new Uint8Array(bytes.buffer.slice(bytes.i, bytes.i + len))\n    bytes.i += len\n    return result\n  })\n\nexport const Bytes = (nBytes?: number): Codec<Uint8Array> =>\n  createCodec(BytesEnc(nBytes), BytesDec(nBytes))\n\nBytes.enc = BytesEnc\nBytes.dec = BytesDec\n", "import {\n  Codec,\n  CodecType,\n  Decoder,\n  DecoderType,\n  Encoder,\n  EncoderType,\n  StringRecord,\n} from \"../types\"\nimport { toInternalBytes, mapObject, mergeUint8 } from \"../internal\"\nimport { createCodec, u8 } from \"../\"\n\ntype Tuple<T, N extends number> = readonly [T, ...T[]] & { length: N }\n\ntype Push<T extends any[], V> = [...T, V]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype LastOf<T> = UnionToIntersection<\n  T extends any ? () => T : never\n> extends () => infer R\n  ? R\n  : never\n\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\ntype RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<\n  T,\n  TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0\n>\n\nconst enumEnc = <O extends StringRecord<Encoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O>,\n): Encoder<\n  {\n    [K in keyof O]: { tag: K; value: EncoderType<O[K]> }\n  }[keyof O]\n> => {\n  const keys = Object.keys(inner)\n  const mappedKeys = new Map<keyof O, number>(\n    x?.map((actualIdx, idx) => [keys[idx], actualIdx]) ??\n      keys.map((key, idx) => [key, idx]),\n  )\n  const getKey = (key: keyof O) => mappedKeys.get(key)!\n\n  return ({ tag, value }) =>\n    mergeUint8([u8.enc(getKey(tag)), (inner as any)[tag](value)])\n}\n\nconst enumDec = <O extends StringRecord<Decoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O>,\n): Decoder<\n  {\n    [K in keyof O]: { tag: K; value: DecoderType<O[K]> }\n  }[keyof O]\n> => {\n  const keys = Object.keys(inner)\n  const mappedKeys = new Map<number, string>(\n    x?.map((actualIdx, idx) => [actualIdx, keys[idx]]) ??\n      keys.map((key, idx) => [idx, key]),\n  )\n\n  return toInternalBytes((bytes) => {\n    const idx = u8.dec(bytes)\n    const tag = mappedKeys.get(idx)!\n    const innerDecoder = inner[tag]\n    return {\n      tag,\n      value: innerDecoder(bytes),\n    }\n  })\n}\n\nexport const Enum = <O extends StringRecord<Codec<any>>>(\n  inner: O,\n  ...args: [indexes?: RestrictedLenTuple<number, O>]\n): Codec<\n  {\n    [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n  }[keyof O]\n> =>\n  createCodec(\n    enumEnc(\n      mapObject(inner, ([encoder]) => encoder) as StringRecord<\n        O[keyof O][\"enc\"]\n      >,\n      ...(args as any[]),\n    ) as Encoder<\n      {\n        [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n      }[keyof O]\n    >,\n    enumDec(\n      mapObject(inner, ([, decoder]) => decoder) as StringRecord<\n        O[keyof O][\"dec\"]\n      >,\n      ...(args as any[]),\n    ) as Decoder<\n      {\n        [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n      }[keyof O]\n    >,\n  )\n\nEnum.enc = enumEnc\nEnum.dec = enumDec\n", "import { Decoder, Encoder, Codec } from \"../types\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { createCodec } from \"../utils\"\nimport { u8 } from \"./fixed-width-ints\"\n\nconst OptionDec = <T>(inner: Decoder<T>): Decoder<T | undefined> =>\n  toInternalBytes<T | undefined>((bytes) =>\n    u8[1](bytes) > 0 ? inner(bytes) : undefined,\n  )\n\nconst OptionEnc =\n  <T>(inner: Encoder<T>): Encoder<T | undefined> =>\n  (value) => {\n    const result = new Uint8Array(1)\n    if (value === undefined) return result\n    result[0] = 1\n    return mergeUint8([result, inner(value)])\n  }\n\nexport const Option = <T>(inner: Codec<T>): Codec<T | undefined> =>\n  createCodec(OptionEnc(inner[0]), OptionDec(inner[1]))\n\nOption.enc = OptionEnc\nOption.dec = OptionDec\n", "import { createCodec } from \"../utils\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { Decoder, Encoder, Codec } from \"../types\"\nimport { u8 } from \"./fixed-width-ints\"\n\nexport type ResultPayload<OK, KO> =\n  | { success: true; value: OK }\n  | { success: false; value: KO }\n\nconst ResultDec = <OK, KO>(\n  okDecoder: Decoder<OK>,\n  koDecoder: Decoder<KO>,\n): Decoder<ResultPayload<OK, KO>> =>\n  toInternalBytes((bytes) => {\n    const success = u8[1](bytes) === 0\n    const decoder = success ? okDecoder : koDecoder\n    const value = decoder(bytes)\n    return { success, value } as ResultPayload<OK, KO>\n  })\n\nconst ResultEnc =\n  <OK, KO>(\n    okEncoder: Encoder<OK>,\n    koEncoder: Encoder<KO>,\n  ): Encoder<ResultPayload<OK, KO>> =>\n  ({ success, value }) =>\n    mergeUint8([\n      u8[0](success ? 0 : 1),\n      (success ? okEncoder : koEncoder)(value as any),\n    ])\n\nexport const Result = <OK, KO>(\n  okCodec: Codec<OK>,\n  koCodec: Codec<KO>,\n): Codec<ResultPayload<OK, KO>> =>\n  createCodec(\n    ResultEnc(okCodec[0], koCodec[0]),\n    ResultDec(okCodec[1], koCodec[1]),\n  )\n\nResult.dec = ResultDec\nResult.enc = ResultEnc\n", "import { Codec, Decoder, Encoder } from \"../types\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { createCodec } from \"../utils\"\n\nconst TupleDec = <A extends Array<Decoder<any>>>(\n  ...decoders: A\n): Decoder<{ [K in keyof A]: A[K] extends Decoder<infer D> ? D : unknown }> =>\n  toInternalBytes((bytes) => decoders.map((decoder) => decoder(bytes)) as any)\n\nconst TupleEnc =\n  <A extends Array<Encoder<any>>>(\n    ...encoders: A\n  ): Encoder<{ [K in keyof A]: A[K] extends Encoder<infer D> ? D : unknown }> =>\n  (values) =>\n    mergeUint8(encoders.map((enc, idx) => enc(values[idx])))\n\nexport const Tuple = <A extends Array<Codec<any>>>(\n  ...codecs: A\n): Codec<{ [K in keyof A]: A[K] extends Codec<infer D> ? D : unknown }> =>\n  createCodec(\n    TupleEnc(...codecs.map(([encoder]) => encoder)),\n    TupleDec(...codecs.map(([, decoder]) => decoder)),\n  ) as any\n\nTuple.enc = TupleEnc\nTuple.dec = TupleDec\n", "import { mapObject } from \"../internal\"\nimport {\n  Codec,\n  EncoderType,\n  DecoderType,\n  CodecType,\n  Decoder,\n  Encoder,\n  StringRecord,\n} from \"../types\"\nimport { createCodec, enhanceDecoder, enhanceEncoder } from \"../utils\"\nimport { Tuple } from \"./Tuple\"\n\nconst StructEnc = <A extends StringRecord<Encoder<any>>>(\n  encoders: A,\n): Encoder<{ [K in keyof A]: EncoderType<A[K]> }> => {\n  const keys = Object.keys(encoders)\n  return enhanceEncoder(\n    Tuple.enc(...Object.values(encoders)),\n    (input: { [K in keyof A]: EncoderType<A[K]> }) => keys.map((k) => input[k]),\n  )\n}\n\nconst StructDec = <A extends StringRecord<Decoder<any>>>(\n  decoders: A,\n): Decoder<{ [K in keyof A]: DecoderType<A[K]> }> => {\n  const keys = Object.keys(decoders)\n  return enhanceDecoder(\n    Tuple.dec(...Object.values(decoders)),\n    (tuple: Array<any>) =>\n      Object.fromEntries(tuple.map((value, idx) => [keys[idx], value])) as any,\n  )\n}\n\nexport const Struct = <A extends StringRecord<Codec<any>>>(\n  codecs: A,\n): Codec<{ [K in keyof A]: CodecType<A[K]> }> =>\n  createCodec(\n    StructEnc(\n      mapObject(codecs, (x) => x[0]) as StringRecord<A[keyof A][0]>,\n    ) as any,\n    StructDec(\n      mapObject(codecs, (x) => x[1]) as StringRecord<A[keyof A][1]>,\n    ) as any,\n  )\n\nStruct.enc = StructEnc\nStruct.dec = StructDec\n", "import { toInternalBytes, mergeUint8 } from \"../internal\"\nimport { createCodec } from \"../utils\"\nimport { Codec, Decoder, Encoder } from \"../types\"\nimport { compact } from \"./compact\"\n\nconst VectorEnc = <T>(inner: Encoder<T>, size?: number): Encoder<Array<T>> =>\n  size! >= 0\n    ? (value) => mergeUint8(value.map(inner))\n    : (value) =>\n        mergeUint8([compact.enc(value.length), mergeUint8(value.map(inner))])\n\nconst VectorDec = <T>(getter: Decoder<T>, size?: number): Decoder<Array<T>> =>\n  toInternalBytes((bytes) => {\n    const nElements = size! >= 0 ? size! : compact.dec(bytes)\n    const result = new Array(nElements as number)\n\n    for (let i = 0; i < nElements; i++) {\n      result[i] = getter(bytes)\n    }\n\n    return result\n  })\n\nexport const Vector = <T>(inner: Codec<T>, size?: number): Codec<Array<T>> =>\n  createCodec(VectorEnc(inner[0], size), VectorDec(inner[1], size))\n\nVector.enc = VectorEnc\nVector.dec = VectorDec\n"],
  "mappings": "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",
  "names": []
}
