{
  "version": 3,
  "sources": ["../src/index.ts", "../src/internal/toInternalBytes.ts", "../src/internal/mergeUint8.ts", "../src/internal/mapObject.ts", "../src/utils.ts", "../src/codecs/fixed-width-ints.ts", "../src/codecs/bool.ts", "../src/codecs/compact.ts", "../src/codecs/str.ts", "../src/codecs/void.ts", "../src/codecs/Bytes.ts", "../src/codecs/Enum.ts", "../src/codecs/Option.ts", "../src/codecs/Result.ts", "../src/codecs/Tuple.ts", "../src/codecs/Struct.ts", "../src/codecs/Vector.ts"],
  "sourcesContent": ["export * from \"./utils\"\nexport * from \"./types\"\nexport * from \"./codecs\"\n", "import { Decoder } from \"../types\"\n\n// https://jsben.ch/URe1X\nconst HEX_MAP: Record<string, number> = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15,\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15,\n}\nexport function fromHex(hexString: string): Uint8Array {\n  const isOdd = hexString.length % 2\n  /* istanbul ignore next */\n  const base = (hexString[1] === \"x\" ? 2 : 0) + isOdd\n  const nBytes = (hexString.length - base) / 2 + isOdd\n  const bytes = new Uint8Array(nBytes)\n\n  if (isOdd) bytes[0] = 0 | HEX_MAP[hexString[2]]\n\n  for (let i = 0; i < nBytes; ) {\n    const idx = base + i * 2\n    const a = HEX_MAP[hexString[idx]]\n    const b = HEX_MAP[hexString[idx + 1]]\n    bytes[isOdd + i++] = (a << 4) | b\n  }\n\n  return bytes\n}\n\nclass InternalUint8Array extends Uint8Array {\n  i: number = 0\n  v: DataView\n\n  constructor(buffer: ArrayBuffer) {\n    super(buffer)\n    this.v = new DataView(buffer)\n  }\n}\n\nexport const toInternalBytes =\n  <T>(fn: (input: InternalUint8Array) => T): Decoder<T> =>\n  (buffer: string | ArrayBuffer | Uint8Array | InternalUint8Array) =>\n    fn(\n      buffer instanceof InternalUint8Array\n        ? buffer\n        : new InternalUint8Array(\n            buffer instanceof Uint8Array\n              ? buffer.buffer\n              : typeof buffer === \"string\"\n              ? fromHex(buffer).buffer\n              : buffer,\n          ),\n    )\n", "export const mergeUint8 = (inputs: Array<Uint8Array>): Uint8Array => {\n  const len = inputs.length\n  let totalLen = 0\n  for (let i = 0; i < len; i++) totalLen += inputs[i].length\n  const result = new Uint8Array(totalLen)\n\n  for (let idx = 0, at = 0; idx < len; idx++) {\n    const current = inputs[idx]\n    result.set(current, at)\n    at += current.byteLength\n  }\n\n  return result\n}\n", "export function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k: K) => O,\n): Record<K, O>\n\nexport function mapObject<K extends string | number | symbol, I, O>(\n  input: Record<K, I>,\n  mapper: (i: I, k?: K) => O,\n): Record<K, O> {\n  const keys = Object.keys(input) as Array<K>\n  const len = keys.length\n\n  const result: Record<K, O> = {} as any\n  for (let i = 0; i < len; i++) {\n    const key = keys[i]\n    result[key] = mapper(input[key], key)\n  }\n\n  return result\n}\n", "import type { Codec, Decoder, Encoder } from \"./types\"\nimport { toInternalBytes } from \"./internal\"\n\nexport const createDecoder: <T>(fn: (input: Uint8Array) => T) => Decoder<T> =\n  toInternalBytes as any\n\nexport const createCodec = <T>(\n  encoder: Encoder<T>,\n  decoder: Decoder<T>,\n): Codec<T> => {\n  const result = [encoder, decoder] as any\n  result.enc = encoder\n  result.dec = decoder\n  return result\n}\n\nexport const enhanceEncoder =\n  <I, O>(encoder: Encoder<I>, mapper: (value: O) => I): Encoder<O> =>\n  (value) =>\n    encoder(mapper(value))\n\nexport const enhanceDecoder =\n  <I, O>(decoder: Decoder<I>, mapper: (value: I) => O): Decoder<O> =>\n  (value) =>\n    mapper(decoder(value))\n\nexport const enhanceCodec = <I, O>(\n  [encoder, decoder]: Codec<I>,\n  toFrom: (value: O) => I,\n  fromTo: (value: I) => O,\n): Codec<O> =>\n  createCodec(enhanceEncoder(encoder, toFrom), enhanceDecoder(decoder, fromTo))\n", "import { createCodec } from \"../utils\"\nimport { Codec, Decoder, Encoder } from \"../types\"\nimport { toInternalBytes } from \"../internal\"\n\nfunction decodeInt(nBytes: 8, getter: keyof DataView): Decoder<bigint>\nfunction decodeInt(nBytes: number, getter: keyof DataView): Decoder<number>\nfunction decodeInt(\n  nBytes: number,\n  getter: keyof DataView,\n): Decoder<number> | Decoder<bigint> {\n  return toInternalBytes((bytes) => {\n    const result = (bytes.v[getter] as any)(bytes.i, true) as number\n    bytes.i += nBytes\n    return result\n  })\n}\n\nfunction encodeInt(nBytes: 8, setter: keyof DataView): Encoder<bigint>\nfunction encodeInt(nBytes: number, setter: keyof DataView): Encoder<number>\nfunction encodeInt(\n  nBytes: number,\n  setter: keyof DataView,\n): Encoder<number> | Encoder<bigint> {\n  return (input: number | bigint) => {\n    const result = new Uint8Array(nBytes)\n    const dv = new DataView(result.buffer)\n    ;(dv[setter] as any)(0, input, true)\n    return result\n  }\n}\n\nfunction intCodec(\n  nBytes: 8,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<bigint>\nfunction intCodec(\n  nBytes: number,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<number>\nfunction intCodec(\n  nBytes: number,\n  getter: keyof DataView,\n  setter: keyof DataView,\n): Codec<bigint> | Codec<number> {\n  return createCodec(encodeInt(nBytes, setter), decodeInt(nBytes, getter))\n}\n\nexport const u8 = intCodec(1, \"getUint8\", \"setUint8\")\nexport const u16 = intCodec(2, \"getUint16\", \"setUint16\")\nexport const u32 = intCodec(4, \"getUint32\", \"setUint32\")\nexport const u64 = intCodec(8, \"getBigUint64\", \"setBigUint64\")\nexport const i8 = intCodec(1, \"getInt8\", \"setInt8\")\nexport const i16 = intCodec(2, \"getInt16\", \"setInt16\")\nexport const i32 = intCodec(4, \"getInt32\", \"setInt32\")\nexport const i64 = intCodec(8, \"getBigInt64\", \"setBigInt64\")\n\nconst x128Enc: Encoder<bigint> = (value) => {\n  const result = new Uint8Array(16)\n  const dv = new DataView(result.buffer)\n  dv.setBigInt64(0, value, true)\n  dv.setBigInt64(8, value >> 64n, true)\n  return result\n}\n\nconst create128Dec = (\n  method: \"getBigInt64\" | \"getBigUint64\",\n): Decoder<bigint> =>\n  toInternalBytes((input) => {\n    const { v, i } = input\n    const right = v.getBigUint64(i, true)\n    const left = v[method](i + 8, true)\n    input.i += 16\n    return (left << 64n) | right\n  })\n\nexport const u128 = createCodec(x128Enc, create128Dec(\"getBigUint64\"))\nexport const i128 = createCodec(x128Enc, create128Dec(\"getBigInt64\"))\n\nconst x256Enc: Encoder<bigint> = (value) => {\n  const result = new Uint8Array(32)\n  const dv = new DataView(result.buffer)\n  dv.setBigInt64(0, value, true)\n  dv.setBigInt64(8, value >> 64n, true)\n  dv.setBigInt64(16, value >> 128n, true)\n  dv.setBigInt64(24, value >> 192n, true)\n  return result\n}\n\nconst create256Dec = (\n  method: \"getBigInt64\" | \"getBigUint64\",\n): Decoder<bigint> =>\n  toInternalBytes((input) => {\n    let result = input.v.getBigUint64(input.i, true)\n    input.i += 8\n\n    result |= input.v.getBigUint64(input.i, true) << 64n\n    input.i += 8\n\n    result |= input.v.getBigUint64(input.i, true) << 128n\n    input.i += 8\n\n    result |= input.v[method](input.i, true) << 192n\n    input.i += 8\n\n    return result\n  })\nexport const u256 = createCodec(x256Enc, create256Dec(\"getBigUint64\"))\nexport const i256 = createCodec(x256Enc, create256Dec(\"getBigInt64\"))\n", "import { Codec } from \"../types\"\nimport { enhanceCodec } from \"../\"\nimport { u8 } from \"./fixed-width-ints\"\n\nexport const bool: Codec<boolean> = enhanceCodec(\n  u8,\n  (value: boolean) => (value ? 1 : 0),\n  Boolean,\n)\n", "import { createCodec } from \"../\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { u8, u16, u32, u64 } from \"./fixed-width-ints\"\nimport { Decoder, Encoder, Codec } from \"../types\"\n\nconst decoders = [u8[1], u16[1], u32[1]] as const\nconst compactDec: Decoder<number | bigint> = toInternalBytes<number | bigint>(\n  (bytes) => {\n    const init = bytes[bytes.i]\n\n    const kind = init & 3\n    if (kind < 3) return decoders[kind](bytes) >>> 2\n\n    const nBytes = (init >>> 2) + 4\n    bytes.i++\n\n    let result = 0n\n\n    const nU64 = (nBytes / 8) | 0\n    let shift = 0n\n    for (let i = 0; i < nU64; i++) {\n      result = (u64[1](bytes) << shift) | result\n      shift += 64n\n    }\n\n    let nReminders = nBytes % 8\n    if (nReminders > 3) {\n      result = (BigInt(u32[1](bytes)) << shift) | result\n      shift += 32n\n      nReminders -= 4\n    }\n\n    if (nReminders > 1) {\n      result = (BigInt(u16[1](bytes)) << shift) | result\n      shift += 16n\n      nReminders -= 2\n    }\n\n    if (nReminders) result = (BigInt(u8[1](bytes)) << shift) | result\n\n    return result\n  },\n)\n\nconst MIN_U64 = 1n << 56n\nconst MIN_U32 = 1 << 24\nconst MIN_U16 = 256\nconst U32_MASK = 4294967295n\n\nconst SINGLE_BYTE_MODE_LIMIT = 1 << 6\nconst TWO_BYTE_MODE_LIMIT = 1 << 14\nconst FOUR_BYTE_MODE_LIMIT = 1 << 30\n\nconst compactEnc: Encoder<number | bigint> = (input) => {\n  if (input < 0) throw new Error(`Wrong compact input (${input})`)\n\n  const nInput = Number(input) << 2\n  if (input < SINGLE_BYTE_MODE_LIMIT) return u8[0](nInput)\n  if (input < TWO_BYTE_MODE_LIMIT) return u16[0](nInput | 1)\n  if (input < FOUR_BYTE_MODE_LIMIT) return u32[0](nInput | 2)\n\n  let buffers: Array<Uint8Array> = [new Uint8Array(1)]\n  let bigValue = BigInt(input)\n  while (bigValue >= MIN_U64) {\n    buffers.push(u64[0](bigValue))\n    bigValue >>= 64n\n  }\n\n  if (bigValue >= MIN_U32) {\n    buffers.push(u32[0](Number(bigValue & U32_MASK)))\n    bigValue >>= 32n\n  }\n\n  let smValue = Number(bigValue)\n  if (smValue >= MIN_U16) {\n    buffers.push(u16[0](smValue))\n    smValue >>= 16\n  }\n\n  smValue && buffers.push(u8[0](smValue))\n\n  const result = mergeUint8(buffers)\n  result[0] = ((result.length - 5) << 2) | 3\n\n  return result\n}\n\nexport const compact: Codec<number | bigint> = createCodec(\n  compactEnc,\n  compactDec,\n)\n", "import { createCodec, Decoder, Encoder } from \"../\"\nimport { toInternalBytes, mergeUint8 } from \"../internal\"\nimport { compact } from \"./compact\"\n\nconst textEncoder = new TextEncoder()\nconst strEnc: Encoder<string> = (str) => {\n  const val = textEncoder.encode(str)\n  return mergeUint8([compact.enc(val.length), val])\n}\n\nconst textDecoder = new TextDecoder()\nconst strDec: Decoder<string> = toInternalBytes((bytes) => {\n  let nElements = compact.dec(bytes) as number\n  const dv = new DataView(bytes.buffer, bytes.i, nElements)\n  bytes.i += nElements\n  return textDecoder.decode(dv)\n})\n\nexport const str = createCodec(strEnc, strDec)\n", "import { Codec } from \"../types\"\nimport { createCodec } from \"../\"\n\nconst noop = (() => {}) as () => undefined\nconst emptyArr = new Uint8Array(0)\nexport const _void: Codec<undefined> = createCodec(() => emptyArr, noop)\n", "import { Encoder, Decoder, Codec } from \"../types\"\nimport { createCodec } from \"../\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { compact } from \"./compact\"\n\nconst BytesEnc = (nBytes?: number): Encoder<Uint8Array> =>\n  nBytes === undefined\n    ? (bytes) => mergeUint8([compact.enc(bytes.length), bytes])\n    : (bytes) => (bytes.length === nBytes ? bytes : bytes.slice(0, nBytes))\n\nconst BytesDec = (nBytes?: number): Decoder<Uint8Array> =>\n  toInternalBytes((bytes) => {\n    const len =\n      nBytes === undefined\n        ? (compact.dec(bytes) as number)\n        : nBytes !== Infinity\n        ? nBytes\n        : bytes.byteLength - bytes.i\n\n    const result = new Uint8Array(bytes.buffer.slice(bytes.i, bytes.i + len))\n    bytes.i += len\n    return result\n  })\n\nexport const Bytes = (nBytes?: number): Codec<Uint8Array> =>\n  createCodec(BytesEnc(nBytes), BytesDec(nBytes))\n\nBytes.enc = BytesEnc\nBytes.dec = BytesDec\n", "import {\n  Codec,\n  CodecType,\n  Decoder,\n  DecoderType,\n  Encoder,\n  EncoderType,\n  StringRecord,\n} from \"../types\"\nimport { toInternalBytes, mapObject, mergeUint8 } from \"../internal\"\nimport { createCodec, u8 } from \"../\"\n\ntype Tuple<T, N extends number> = readonly [T, ...T[]] & { length: N }\n\ntype Push<T extends any[], V> = [...T, V]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never\n\ntype LastOf<T> = UnionToIntersection<\n  T extends any ? () => T : never\n> extends () => infer R\n  ? R\n  : never\n\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false,\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>\n\ntype RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<\n  T,\n  TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0\n>\n\nconst enumEnc = <O extends StringRecord<Encoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O>,\n): Encoder<\n  {\n    [K in keyof O]: { tag: K; value: EncoderType<O[K]> }\n  }[keyof O]\n> => {\n  const keys = Object.keys(inner)\n  const mappedKeys = new Map<keyof O, number>(\n    x?.map((actualIdx, idx) => [keys[idx], actualIdx]) ??\n      keys.map((key, idx) => [key, idx]),\n  )\n  const getKey = (key: keyof O) => mappedKeys.get(key)!\n\n  return ({ tag, value }) =>\n    mergeUint8([u8.enc(getKey(tag)), (inner as any)[tag](value)])\n}\n\nconst enumDec = <O extends StringRecord<Decoder<any>>>(\n  inner: O,\n  x?: RestrictedLenTuple<number, O>,\n): Decoder<\n  {\n    [K in keyof O]: { tag: K; value: DecoderType<O[K]> }\n  }[keyof O]\n> => {\n  const keys = Object.keys(inner)\n  const mappedKeys = new Map<number, string>(\n    x?.map((actualIdx, idx) => [actualIdx, keys[idx]]) ??\n      keys.map((key, idx) => [idx, key]),\n  )\n\n  return toInternalBytes((bytes) => {\n    const idx = u8.dec(bytes)\n    const tag = mappedKeys.get(idx)!\n    const innerDecoder = inner[tag]\n    return {\n      tag,\n      value: innerDecoder(bytes),\n    }\n  })\n}\n\nexport const Enum = <O extends StringRecord<Codec<any>>>(\n  inner: O,\n  ...args: [indexes?: RestrictedLenTuple<number, O>]\n): Codec<\n  {\n    [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n  }[keyof O]\n> =>\n  createCodec(\n    enumEnc(\n      mapObject(inner, ([encoder]) => encoder) as StringRecord<\n        O[keyof O][\"enc\"]\n      >,\n      ...(args as any[]),\n    ) as Encoder<\n      {\n        [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n      }[keyof O]\n    >,\n    enumDec(\n      mapObject(inner, ([, decoder]) => decoder) as StringRecord<\n        O[keyof O][\"dec\"]\n      >,\n      ...(args as any[]),\n    ) as Decoder<\n      {\n        [K in keyof O]: { tag: K; value: CodecType<O[K]> }\n      }[keyof O]\n    >,\n  )\n\nEnum.enc = enumEnc\nEnum.dec = enumDec\n", "import { Decoder, Encoder, Codec } from \"../types\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { createCodec } from \"../utils\"\nimport { u8 } from \"./fixed-width-ints\"\n\nconst OptionDec = <T>(inner: Decoder<T>): Decoder<T | undefined> =>\n  toInternalBytes<T | undefined>((bytes) =>\n    u8[1](bytes) > 0 ? inner(bytes) : undefined,\n  )\n\nconst OptionEnc =\n  <T>(inner: Encoder<T>): Encoder<T | undefined> =>\n  (value) => {\n    const result = new Uint8Array(1)\n    if (value === undefined) return result\n    result[0] = 1\n    return mergeUint8([result, inner(value)])\n  }\n\nexport const Option = <T>(inner: Codec<T>): Codec<T | undefined> =>\n  createCodec(OptionEnc(inner[0]), OptionDec(inner[1]))\n\nOption.enc = OptionEnc\nOption.dec = OptionDec\n", "import { createCodec } from \"../utils\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { Decoder, Encoder, Codec } from \"../types\"\nimport { u8 } from \"./fixed-width-ints\"\n\nexport type ResultPayload<OK, KO> =\n  | { success: true; value: OK }\n  | { success: false; value: KO }\n\nconst ResultDec = <OK, KO>(\n  okDecoder: Decoder<OK>,\n  koDecoder: Decoder<KO>,\n): Decoder<ResultPayload<OK, KO>> =>\n  toInternalBytes((bytes) => {\n    const success = u8[1](bytes) === 0\n    const decoder = success ? okDecoder : koDecoder\n    const value = decoder(bytes)\n    return { success, value } as ResultPayload<OK, KO>\n  })\n\nconst ResultEnc =\n  <OK, KO>(\n    okEncoder: Encoder<OK>,\n    koEncoder: Encoder<KO>,\n  ): Encoder<ResultPayload<OK, KO>> =>\n  ({ success, value }) =>\n    mergeUint8([\n      u8[0](success ? 0 : 1),\n      (success ? okEncoder : koEncoder)(value as any),\n    ])\n\nexport const Result = <OK, KO>(\n  okCodec: Codec<OK>,\n  koCodec: Codec<KO>,\n): Codec<ResultPayload<OK, KO>> =>\n  createCodec(\n    ResultEnc(okCodec[0], koCodec[0]),\n    ResultDec(okCodec[1], koCodec[1]),\n  )\n\nResult.dec = ResultDec\nResult.enc = ResultEnc\n", "import { Codec, Decoder, Encoder } from \"../types\"\nimport { mergeUint8, toInternalBytes } from \"../internal\"\nimport { createCodec } from \"../utils\"\n\nconst TupleDec = <A extends Array<Decoder<any>>>(\n  ...decoders: A\n): Decoder<{ [K in keyof A]: A[K] extends Decoder<infer D> ? D : unknown }> =>\n  toInternalBytes((bytes) => decoders.map((decoder) => decoder(bytes)) as any)\n\nconst TupleEnc =\n  <A extends Array<Encoder<any>>>(\n    ...encoders: A\n  ): Encoder<{ [K in keyof A]: A[K] extends Encoder<infer D> ? D : unknown }> =>\n  (values) =>\n    mergeUint8(encoders.map((enc, idx) => enc(values[idx])))\n\nexport const Tuple = <A extends Array<Codec<any>>>(\n  ...codecs: A\n): Codec<{ [K in keyof A]: A[K] extends Codec<infer D> ? D : unknown }> =>\n  createCodec(\n    TupleEnc(...codecs.map(([encoder]) => encoder)),\n    TupleDec(...codecs.map(([, decoder]) => decoder)),\n  ) as any\n\nTuple.enc = TupleEnc\nTuple.dec = TupleDec\n", "import { mapObject } from \"../internal\"\nimport {\n  Codec,\n  EncoderType,\n  DecoderType,\n  CodecType,\n  Decoder,\n  Encoder,\n  StringRecord,\n} from \"../types\"\nimport { createCodec, enhanceDecoder, enhanceEncoder } from \"../utils\"\nimport { Tuple } from \"./Tuple\"\n\nconst StructEnc = <A extends StringRecord<Encoder<any>>>(\n  encoders: A,\n): Encoder<{ [K in keyof A]: EncoderType<A[K]> }> => {\n  const keys = Object.keys(encoders)\n  return enhanceEncoder(\n    Tuple.enc(...Object.values(encoders)),\n    (input: { [K in keyof A]: EncoderType<A[K]> }) => keys.map((k) => input[k]),\n  )\n}\n\nconst StructDec = <A extends StringRecord<Decoder<any>>>(\n  decoders: A,\n): Decoder<{ [K in keyof A]: DecoderType<A[K]> }> => {\n  const keys = Object.keys(decoders)\n  return enhanceDecoder(\n    Tuple.dec(...Object.values(decoders)),\n    (tuple: Array<any>) =>\n      Object.fromEntries(tuple.map((value, idx) => [keys[idx], value])) as any,\n  )\n}\n\nexport const Struct = <A extends StringRecord<Codec<any>>>(\n  codecs: A,\n): Codec<{ [K in keyof A]: CodecType<A[K]> }> =>\n  createCodec(\n    StructEnc(\n      mapObject(codecs, (x) => x[0]) as StringRecord<A[keyof A][0]>,\n    ) as any,\n    StructDec(\n      mapObject(codecs, (x) => x[1]) as StringRecord<A[keyof A][1]>,\n    ) as any,\n  )\n\nStruct.enc = StructEnc\nStruct.dec = StructDec\n", "import { toInternalBytes, mergeUint8 } from \"../internal\"\nimport { createCodec } from \"../utils\"\nimport { Codec, Decoder, Encoder } from \"../types\"\nimport { compact } from \"./compact\"\n\nconst VectorEnc = <T>(inner: Encoder<T>, size?: number): Encoder<Array<T>> =>\n  size! >= 0\n    ? (value) => mergeUint8(value.map(inner))\n    : (value) =>\n        mergeUint8([compact.enc(value.length), mergeUint8(value.map(inner))])\n\nconst VectorDec = <T>(getter: Decoder<T>, size?: number): Decoder<Array<T>> =>\n  toInternalBytes((bytes) => {\n    const nElements = size! >= 0 ? size! : compact.dec(bytes)\n    const result = new Array(nElements as number)\n\n    for (let i = 0; i < nElements; i++) {\n      result[i] = getter(bytes)\n    }\n\n    return result\n  })\n\nexport const Vector = <T>(inner: Codec<T>, size?: number): Codec<Array<T>> =>\n  createCodec(VectorEnc(inner[0], size), VectorDec(inner[1], size))\n\nVector.enc = VectorEnc\nVector.dec = VectorDec\n"],
  "mappings": "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",
  "names": []
}
