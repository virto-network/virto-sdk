import { Codec, CodecType, Decoder, DecoderType, Encoder, EncoderType, StringRecord } from "../types";
declare type Tuple<T, N extends number> = readonly [T, ...T[]] & {
    length: N;
};
declare type Push<T extends any[], V> = [...T, V];
declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
declare type LastOf<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R ? R : never;
declare type TuplifyUnion<T, L = LastOf<T>, N = [T] extends [never] ? true : false> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>;
declare type RestrictedLenTuple<T, O extends StringRecord<any>> = Tuple<T, TuplifyUnion<keyof O> extends Tuple<any, infer V> ? V : 0>;
export declare const Enum: {
    <O extends StringRecord<Codec<any>>>(inner: O, indexes?: RestrictedLenTuple<number, O> | undefined): Codec<{ [K in keyof O]: {
        tag: K;
        value: CodecType<O[K]>;
    }; }[keyof O]>;
    enc: <O_1 extends StringRecord<Encoder<any>>>(inner: O_1, x?: RestrictedLenTuple<number, O_1> | undefined) => Encoder<{ [K_1 in keyof O_1]: {
        tag: K_1;
        value: EncoderType<O_1[K_1]>;
    }; }[keyof O_1]>;
    dec: <O_2 extends StringRecord<Decoder<any>>>(inner: O_2, x?: RestrictedLenTuple<number, O_2> | undefined) => Decoder<{ [K_2 in keyof O_2]: {
        tag: K_2;
        value: DecoderType<O_2[K_2]>;
    }; }[keyof O_2]>;
};
export {};
