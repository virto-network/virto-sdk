var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/internal/toInternalBytes.ts
var HEX_MAP = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};
function fromHex(hexString) {
  const isOdd = hexString.length % 2;
  const base = (hexString[1] === "x" ? 2 : 0) + isOdd;
  const nBytes = (hexString.length - base) / 2 + isOdd;
  const bytes = new Uint8Array(nBytes);
  if (isOdd)
    bytes[0] = 0 | HEX_MAP[hexString[2]];
  for (let i = 0; i < nBytes; ) {
    const idx = base + i * 2;
    const a = HEX_MAP[hexString[idx]];
    const b = HEX_MAP[hexString[idx + 1]];
    bytes[isOdd + i++] = a << 4 | b;
  }
  return bytes;
}
var InternalUint8Array = class extends Uint8Array {
  constructor(buffer) {
    super(buffer);
    __publicField(this, "i", 0);
    __publicField(this, "v");
    this.v = new DataView(buffer);
  }
};
var toInternalBytes = (fn) => (buffer) => fn(buffer instanceof InternalUint8Array ? buffer : new InternalUint8Array(buffer instanceof Uint8Array ? buffer.buffer : typeof buffer === "string" ? fromHex(buffer).buffer : buffer));

// src/internal/mergeUint8.ts
var mergeUint8 = (inputs) => {
  const len = inputs.length;
  let totalLen = 0;
  for (let i = 0; i < len; i++)
    totalLen += inputs[i].length;
  const result = new Uint8Array(totalLen);
  for (let idx = 0, at = 0; idx < len; idx++) {
    const current = inputs[idx];
    result.set(current, at);
    at += current.byteLength;
  }
  return result;
};

// src/internal/mapObject.ts
function mapObject(input, mapper) {
  const keys = Object.keys(input);
  const len = keys.length;
  const result = {};
  for (let i = 0; i < len; i++) {
    const key = keys[i];
    result[key] = mapper(input[key], key);
  }
  return result;
}

// src/utils.ts
var createDecoder = toInternalBytes;
var createCodec = (encoder, decoder) => {
  const result = [encoder, decoder];
  result.enc = encoder;
  result.dec = decoder;
  return result;
};
var enhanceEncoder = (encoder, mapper) => (value) => encoder(mapper(value));
var enhanceDecoder = (decoder, mapper) => (value) => mapper(decoder(value));
var enhanceCodec = ([encoder, decoder], toFrom, fromTo) => createCodec(enhanceEncoder(encoder, toFrom), enhanceDecoder(decoder, fromTo));

// src/codecs/fixed-width-ints.ts
function decodeInt(nBytes, getter) {
  return toInternalBytes((bytes) => {
    const result = bytes.v[getter](bytes.i, true);
    bytes.i += nBytes;
    return result;
  });
}
function encodeInt(nBytes, setter) {
  return (input) => {
    const result = new Uint8Array(nBytes);
    const dv = new DataView(result.buffer);
    dv[setter](0, input, true);
    return result;
  };
}
function intCodec(nBytes, getter, setter) {
  return createCodec(encodeInt(nBytes, setter), decodeInt(nBytes, getter));
}
var u8 = intCodec(1, "getUint8", "setUint8");
var u16 = intCodec(2, "getUint16", "setUint16");
var u32 = intCodec(4, "getUint32", "setUint32");
var u64 = intCodec(8, "getBigUint64", "setBigUint64");
var i8 = intCodec(1, "getInt8", "setInt8");
var i16 = intCodec(2, "getInt16", "setInt16");
var i32 = intCodec(4, "getInt32", "setInt32");
var i64 = intCodec(8, "getBigInt64", "setBigInt64");
var x128Enc = (value) => {
  const result = new Uint8Array(16);
  const dv = new DataView(result.buffer);
  dv.setBigInt64(0, value, true);
  dv.setBigInt64(8, value >> 64n, true);
  return result;
};
var create128Dec = (method) => toInternalBytes((input) => {
  const { v, i } = input;
  const right = v.getBigUint64(i, true);
  const left = v[method](i + 8, true);
  input.i += 16;
  return left << 64n | right;
});
var u128 = createCodec(x128Enc, create128Dec("getBigUint64"));
var i128 = createCodec(x128Enc, create128Dec("getBigInt64"));
var x256Enc = (value) => {
  const result = new Uint8Array(32);
  const dv = new DataView(result.buffer);
  dv.setBigInt64(0, value, true);
  dv.setBigInt64(8, value >> 64n, true);
  dv.setBigInt64(16, value >> 128n, true);
  dv.setBigInt64(24, value >> 192n, true);
  return result;
};
var create256Dec = (method) => toInternalBytes((input) => {
  let result = input.v.getBigUint64(input.i, true);
  input.i += 8;
  result |= input.v.getBigUint64(input.i, true) << 64n;
  input.i += 8;
  result |= input.v.getBigUint64(input.i, true) << 128n;
  input.i += 8;
  result |= input.v[method](input.i, true) << 192n;
  input.i += 8;
  return result;
});
var u256 = createCodec(x256Enc, create256Dec("getBigUint64"));
var i256 = createCodec(x256Enc, create256Dec("getBigInt64"));

// src/codecs/bool.ts
var bool = enhanceCodec(u8, (value) => value ? 1 : 0, Boolean);

// src/codecs/compact.ts
var decoders = [u8[1], u16[1], u32[1]];
var compactDec = toInternalBytes((bytes) => {
  const init = bytes[bytes.i];
  const kind = init & 3;
  if (kind < 3)
    return decoders[kind](bytes) >>> 2;
  const nBytes = (init >>> 2) + 4;
  bytes.i++;
  let result = 0n;
  const nU64 = nBytes / 8 | 0;
  let shift = 0n;
  for (let i = 0; i < nU64; i++) {
    result = u64[1](bytes) << shift | result;
    shift += 64n;
  }
  let nReminders = nBytes % 8;
  if (nReminders > 3) {
    result = BigInt(u32[1](bytes)) << shift | result;
    shift += 32n;
    nReminders -= 4;
  }
  if (nReminders > 1) {
    result = BigInt(u16[1](bytes)) << shift | result;
    shift += 16n;
    nReminders -= 2;
  }
  if (nReminders)
    result = BigInt(u8[1](bytes)) << shift | result;
  return result;
});
var MIN_U64 = 1n << 56n;
var MIN_U32 = 1 << 24;
var MIN_U16 = 256;
var U32_MASK = 4294967295n;
var SINGLE_BYTE_MODE_LIMIT = 1 << 6;
var TWO_BYTE_MODE_LIMIT = 1 << 14;
var FOUR_BYTE_MODE_LIMIT = 1 << 30;
var compactEnc = (input) => {
  if (input < 0)
    throw new Error(`Wrong compact input (${input})`);
  const nInput = Number(input) << 2;
  if (input < SINGLE_BYTE_MODE_LIMIT)
    return u8[0](nInput);
  if (input < TWO_BYTE_MODE_LIMIT)
    return u16[0](nInput | 1);
  if (input < FOUR_BYTE_MODE_LIMIT)
    return u32[0](nInput | 2);
  let buffers = [new Uint8Array(1)];
  let bigValue = BigInt(input);
  while (bigValue >= MIN_U64) {
    buffers.push(u64[0](bigValue));
    bigValue >>= 64n;
  }
  if (bigValue >= MIN_U32) {
    buffers.push(u32[0](Number(bigValue & U32_MASK)));
    bigValue >>= 32n;
  }
  let smValue = Number(bigValue);
  if (smValue >= MIN_U16) {
    buffers.push(u16[0](smValue));
    smValue >>= 16;
  }
  smValue && buffers.push(u8[0](smValue));
  const result = mergeUint8(buffers);
  result[0] = result.length - 5 << 2 | 3;
  return result;
};
var compact = createCodec(compactEnc, compactDec);

// src/codecs/str.ts
var textEncoder = new TextEncoder();
var strEnc = (str2) => {
  const val = textEncoder.encode(str2);
  return mergeUint8([compact.enc(val.length), val]);
};
var textDecoder = new TextDecoder();
var strDec = toInternalBytes((bytes) => {
  let nElements = compact.dec(bytes);
  const dv = new DataView(bytes.buffer, bytes.i, nElements);
  bytes.i += nElements;
  return textDecoder.decode(dv);
});
var str = createCodec(strEnc, strDec);

// src/codecs/void.ts
var noop = () => {
};
var emptyArr = new Uint8Array(0);
var _void = createCodec(() => emptyArr, noop);

// src/codecs/Bytes.ts
var BytesEnc = (nBytes) => nBytes === void 0 ? (bytes) => mergeUint8([compact.enc(bytes.length), bytes]) : (bytes) => bytes.length === nBytes ? bytes : bytes.slice(0, nBytes);
var BytesDec = (nBytes) => toInternalBytes((bytes) => {
  const len = nBytes === void 0 ? compact.dec(bytes) : nBytes !== Infinity ? nBytes : bytes.byteLength - bytes.i;
  const result = new Uint8Array(bytes.buffer.slice(bytes.i, bytes.i + len));
  bytes.i += len;
  return result;
});
var Bytes = (nBytes) => createCodec(BytesEnc(nBytes), BytesDec(nBytes));
Bytes.enc = BytesEnc;
Bytes.dec = BytesDec;

// src/codecs/Enum.ts
var enumEnc = (inner, x) => {
  const keys = Object.keys(inner);
  const mappedKeys = new Map(x?.map((actualIdx, idx) => [keys[idx], actualIdx]) ?? keys.map((key, idx) => [key, idx]));
  const getKey = (key) => mappedKeys.get(key);
  return ({ tag, value }) => mergeUint8([u8.enc(getKey(tag)), inner[tag](value)]);
};
var enumDec = (inner, x) => {
  const keys = Object.keys(inner);
  const mappedKeys = new Map(x?.map((actualIdx, idx) => [actualIdx, keys[idx]]) ?? keys.map((key, idx) => [idx, key]));
  return toInternalBytes((bytes) => {
    const idx = u8.dec(bytes);
    const tag = mappedKeys.get(idx);
    const innerDecoder = inner[tag];
    return {
      tag,
      value: innerDecoder(bytes)
    };
  });
};
var Enum = (inner, ...args) => createCodec(enumEnc(mapObject(inner, ([encoder]) => encoder), ...args), enumDec(mapObject(inner, ([, decoder]) => decoder), ...args));
Enum.enc = enumEnc;
Enum.dec = enumDec;

// src/codecs/Option.ts
var OptionDec = (inner) => toInternalBytes((bytes) => u8[1](bytes) > 0 ? inner(bytes) : void 0);
var OptionEnc = (inner) => (value) => {
  const result = new Uint8Array(1);
  if (value === void 0)
    return result;
  result[0] = 1;
  return mergeUint8([result, inner(value)]);
};
var Option = (inner) => createCodec(OptionEnc(inner[0]), OptionDec(inner[1]));
Option.enc = OptionEnc;
Option.dec = OptionDec;

// src/codecs/Result.ts
var ResultDec = (okDecoder, koDecoder) => toInternalBytes((bytes) => {
  const success = u8[1](bytes) === 0;
  const decoder = success ? okDecoder : koDecoder;
  const value = decoder(bytes);
  return { success, value };
});
var ResultEnc = (okEncoder, koEncoder) => ({ success, value }) => mergeUint8([
  u8[0](success ? 0 : 1),
  (success ? okEncoder : koEncoder)(value)
]);
var Result = (okCodec, koCodec) => createCodec(ResultEnc(okCodec[0], koCodec[0]), ResultDec(okCodec[1], koCodec[1]));
Result.dec = ResultDec;
Result.enc = ResultEnc;

// src/codecs/Tuple.ts
var TupleDec = (...decoders2) => toInternalBytes((bytes) => decoders2.map((decoder) => decoder(bytes)));
var TupleEnc = (...encoders) => (values) => mergeUint8(encoders.map((enc, idx) => enc(values[idx])));
var Tuple = (...codecs) => createCodec(TupleEnc(...codecs.map(([encoder]) => encoder)), TupleDec(...codecs.map(([, decoder]) => decoder)));
Tuple.enc = TupleEnc;
Tuple.dec = TupleDec;

// src/codecs/Struct.ts
var StructEnc = (encoders) => {
  const keys = Object.keys(encoders);
  return enhanceEncoder(Tuple.enc(...Object.values(encoders)), (input) => keys.map((k) => input[k]));
};
var StructDec = (decoders2) => {
  const keys = Object.keys(decoders2);
  return enhanceDecoder(Tuple.dec(...Object.values(decoders2)), (tuple) => Object.fromEntries(tuple.map((value, idx) => [keys[idx], value])));
};
var Struct = (codecs) => createCodec(StructEnc(mapObject(codecs, (x) => x[0])), StructDec(mapObject(codecs, (x) => x[1])));
Struct.enc = StructEnc;
Struct.dec = StructDec;

// src/codecs/Vector.ts
var VectorEnc = (inner, size) => size >= 0 ? (value) => mergeUint8(value.map(inner)) : (value) => mergeUint8([compact.enc(value.length), mergeUint8(value.map(inner))]);
var VectorDec = (getter, size) => toInternalBytes((bytes) => {
  const nElements = size >= 0 ? size : compact.dec(bytes);
  const result = new Array(nElements);
  for (let i = 0; i < nElements; i++) {
    result[i] = getter(bytes);
  }
  return result;
});
var Vector = (inner, size) => createCodec(VectorEnc(inner[0], size), VectorDec(inner[1], size));
Vector.enc = VectorEnc;
Vector.dec = VectorDec;
export {
  Bytes,
  Enum,
  Option,
  Result,
  Struct,
  Tuple,
  Vector,
  _void,
  bool,
  compact,
  createCodec,
  createDecoder,
  enhanceCodec,
  enhanceDecoder,
  enhanceEncoder,
  i128,
  i16,
  i256,
  i32,
  i64,
  i8,
  str,
  u128,
  u16,
  u256,
  u32,
  u64,
  u8
};
//# sourceMappingURL=scale-ts.js.map
