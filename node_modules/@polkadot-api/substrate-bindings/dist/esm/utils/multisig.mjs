import { mergeUint8 } from '@polkadot-api/utils';
import { compact, u16 } from 'scale-ts';
import './ss58-util.mjs';
import { Binary } from '../codecs/scale/Binary.mjs';
import '../codecs/scale/bitSequence.mjs';
import '../codecs/scale/char.mjs';
import '../codecs/scale/compact.mjs';
import '../codecs/scale/Hex.mjs';
import '../codecs/scale/fixed-str.mjs';
import '../codecs/scale/Variant.mjs';
import '../codecs/scale/ethAccount.mjs';
import '../codecs/scale/shaped.mjs';
import '../codecs/blockHeader.mjs';
import '../codecs/metadata/metadata.mjs';
import '../codecs/metadata/v14.mjs';
import '../codecs/metadata/v15.mjs';
import '../codecs/metadata/v16.mjs';
import '../codecs/metadata/lookup.mjs';
import { Blake2256 } from '../hashes/blake2.mjs';
import '@noble/hashes/blake3';

const PREFIX = Binary.fromText("modlpy/utilisuba").asBytes();
const getMultisigAccountId = ({
  threshold,
  signatories
}) => {
  const sortedSignatories = sortMultisigSignatories(signatories);
  const payload = mergeUint8([
    PREFIX,
    compact.enc(sortedSignatories.length),
    ...sortedSignatories,
    u16.enc(threshold)
  ]);
  return Blake2256(payload);
};
const sortMultisigSignatories = (signatories) => signatories.slice().sort((a, b) => {
  for (let i = 0; ; i++) {
    const overA = i >= a.length;
    const overB = i >= b.length;
    if (overA && overB) return 0;
    else if (overA) return -1;
    else if (overB) return 1;
    else if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
  }
});

export { getMultisigAccountId, sortMultisigSignatories };
//# sourceMappingURL=multisig.mjs.map
