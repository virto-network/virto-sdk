{"version":3,"file":"storage.mjs","sources":["../../src/storage.ts"],"sourcesContent":["import { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport type { Codec } from \"scale-ts\"\nimport {\n  Blake2128,\n  Blake2128Concat,\n  Blake2256,\n  Identity,\n  Twox128,\n  Twox256,\n  Twox64Concat,\n} from \"./hashes\"\n\nexport type EncoderWithHash<T> = [Codec<T>, (input: Uint8Array) => Uint8Array]\n\nconst textEncoder = new TextEncoder()\n\n// the value indicates:\n// - when positive: the number of bytes to skip before reaching the transparent-encoded key\n// - when negative: the number of bytes that the opaque hasher will generate\nconst hashers: Map<(input: Uint8Array) => Uint8Array, number> = new Map([\n  [Identity, 0],\n  [Twox64Concat, 8],\n  [Blake2128Concat, 16],\n  [Blake2128, -16],\n  [Blake2256, -32],\n  [Twox128, -16],\n  [Twox256, -32],\n])\n\nexport type OpaqueKeyHash = string & { __opaqueKeyHash?: unknown }\n\nexport const Storage = (pallet: string) => {\n  const palledEncoded = Twox128(textEncoder.encode(pallet))\n  return <A extends Array<EncoderWithHash<any>>>(\n    name: string,\n    ...encoders: [...A]\n  ): {\n    enc: (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ) => string\n    dec: (value: string) => {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    }\n  } => {\n    const palletItemEncoded = mergeUint8([\n      palledEncoded,\n      Twox128(textEncoder.encode(name)),\n    ])\n\n    const palletItemEncodedHex = toHex(palletItemEncoded)\n\n    const dec = (\n      key: string,\n    ): {\n      [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n    } => {\n      if (!key.startsWith(palletItemEncodedHex))\n        throw new Error(`key does not match this storage (${pallet}.${name})`)\n\n      if (encoders.length === 0) return [] as any\n\n      const argsKey = fromHex(key.slice(palletItemEncodedHex.length))\n      const result = new Array<any>(encoders.length)\n      for (let i = 0, cur = 0; i < encoders.length; i++) {\n        const [codec, hasher] = encoders[i]\n        const hBytes = hashers.get(hasher)\n        if (hBytes == null) throw new Error(\"Unknown hasher\")\n        if (hBytes < 0) {\n          const opaqueBytes = hBytes * -1\n          result[i] = toHex(argsKey.slice(cur, cur + opaqueBytes))\n          cur += opaqueBytes\n        } else {\n          cur += hBytes\n          result[i] = codec.dec(argsKey.slice(cur))\n          cur += codec.enc(result[i]).length\n        }\n      }\n      return result as any\n    }\n\n    const fns = encoders.map(\n      ([{ enc }, hash]) =>\n        (val: any) =>\n          hash(enc(val)),\n    )\n\n    const enc = (\n      ...args: {\n        [K in keyof A]: A[K] extends EncoderWithHash<infer V> ? V : unknown\n      }\n    ): string =>\n      toHex(\n        mergeUint8([\n          palletItemEncoded,\n          ...args.map((val, idx) => fns[idx](val)),\n        ]),\n      )\n\n    return {\n      enc,\n      dec,\n    }\n  }\n}\n"],"names":["enc"],"mappings":"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"}