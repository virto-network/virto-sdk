import { mergeUint8, toHex, fromHex } from '@polkadot-api/utils';
import { Blake2128Concat, Blake2128, Blake2256 } from './hashes/blake2.mjs';
import '@noble/hashes/blake3';
import { Identity } from './hashes/identity.mjs';
import { Twox128, Twox64Concat, Twox256 } from './hashes/twoX.mjs';

const textEncoder = new TextEncoder();
const hashers = /* @__PURE__ */ new Map([
  [Identity, 0],
  [Twox64Concat, 8],
  [Blake2128Concat, 16],
  [Blake2128, -16],
  [Blake2256, -32],
  [Twox128, -16],
  [Twox256, -32]
]);
const Storage = (pallet) => {
  const palledEncoded = Twox128(textEncoder.encode(pallet));
  return (name, ...encoders) => {
    const palletItemEncoded = mergeUint8([
      palledEncoded,
      Twox128(textEncoder.encode(name))
    ]);
    const palletItemEncodedHex = toHex(palletItemEncoded);
    const dec = (key) => {
      if (!key.startsWith(palletItemEncodedHex))
        throw new Error(`key does not match this storage (${pallet}.${name})`);
      if (encoders.length === 0) return [];
      const argsKey = fromHex(key.slice(palletItemEncodedHex.length));
      const result = new Array(encoders.length);
      for (let i = 0, cur = 0; i < encoders.length; i++) {
        const [codec, hasher] = encoders[i];
        const hBytes = hashers.get(hasher);
        if (hBytes == null) throw new Error("Unknown hasher");
        if (hBytes < 0) {
          const opaqueBytes = hBytes * -1;
          result[i] = toHex(argsKey.slice(cur, cur + opaqueBytes));
          cur += opaqueBytes;
        } else {
          cur += hBytes;
          result[i] = codec.dec(argsKey.slice(cur));
          cur += codec.enc(result[i]).length;
        }
      }
      return result;
    };
    const fns = encoders.map(
      ([{ enc: enc2 }, hash]) => (val) => hash(enc2(val))
    );
    const enc = (...args) => toHex(
      mergeUint8([
        palletItemEncoded,
        ...args.map((val, idx) => fns[idx](val))
      ])
    );
    return {
      enc,
      dec
    };
  };
};

export { Storage };
//# sourceMappingURL=storage.mjs.map
