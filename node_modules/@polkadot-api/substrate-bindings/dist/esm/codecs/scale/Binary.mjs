import { Tuple, compact, Bytes, createCodec } from 'scale-ts';
import { fromHex, toHex, mergeUint8 } from '@polkadot-api/utils';
import { AccountId } from './AccountId.mjs';

var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var _bytes, _opaqueBytes, _hex, _opaqueHex, _str;
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const opaqueBytesDec = Tuple(compact, Bytes(Infinity))[1];
class Binary {
  constructor(data, opaque = false) {
    __privateAdd(this, _bytes);
    __privateAdd(this, _opaqueBytes, null);
    __privateAdd(this, _hex, null);
    __privateAdd(this, _opaqueHex, null);
    __privateAdd(this, _str, null);
    __publicField(this, "asText", () => __privateGet(this, _str) ?? __privateSet(this, _str, textDecoder.decode(__privateGet(this, _bytes))));
    __publicField(this, "asHex", () => __privateGet(this, _hex) || __privateSet(this, _hex, toHex(__privateGet(this, _bytes))));
    __publicField(this, "asOpaqueHex", () => __privateGet(this, _opaqueHex) || __privateSet(this, _opaqueHex, toHex(this.asBytes())));
    __publicField(this, "asBytes", () => __privateGet(this, _bytes));
    __publicField(this, "asOpaqueBytes", () => __privateGet(this, _opaqueBytes) || __privateSet(this, _opaqueBytes, mergeUint8([
      __privateGet(this, _bytes),
      compact[0](__privateGet(this, _bytes).length)
    ])));
    if (opaque) {
      try {
        const [len, bytes] = opaqueBytesDec(data);
        if (len === bytes.length) {
          __privateSet(this, _bytes, bytes);
          __privateSet(this, _opaqueBytes, data);
          return;
        }
      } catch (_) {
      }
      throw new Error("Invalid opaque bytes");
    } else __privateSet(this, _bytes, data);
  }
  static fromText(input) {
    return new this(textEncoder.encode(input));
  }
  static fromHex(input) {
    return new this(fromHex(input));
  }
  static fromOpaqueHex(input) {
    return new this(fromHex(input), true);
  }
  static fromBytes(input) {
    return new this(input);
  }
  static fromOpaqueBytes(input) {
    return new this(input, true);
  }
}
_bytes = new WeakMap();
_opaqueBytes = new WeakMap();
_hex = new WeakMap();
_opaqueHex = new WeakMap();
_str = new WeakMap();
const [accountIdEncoder] = AccountId();
class FixedSizeBinary extends Binary {
  constructor(data) {
    super(data);
  }
  static fromArray(input) {
    return new this(new Uint8Array(input));
  }
  static fromAccountId32(input) {
    return new this(accountIdEncoder(input));
  }
}
const enc = (nBytes) => {
  const _enc = Bytes.enc(nBytes);
  return (value) => _enc(value.asBytes());
};
const dec = (nBytes) => {
  const _dec = Bytes.dec(nBytes);
  const Bin2 = nBytes == null ? Binary : FixedSizeBinary;
  return (value) => Bin2.fromBytes(_dec(value));
};
const Bin = (nBytes) => createCodec(enc(nBytes), dec(nBytes));
Bin.enc = enc;
Bin.dec = dec;

export { Bin, Binary, FixedSizeBinary };
//# sourceMappingURL=Binary.mjs.map
