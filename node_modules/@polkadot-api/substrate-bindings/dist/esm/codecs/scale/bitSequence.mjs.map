{"version":3,"file":"bitSequence.mjs","sources":["../../../../src/codecs/scale/bitSequence.ts"],"sourcesContent":["import { Bytes, Decoder, Encoder, createCodec, createDecoder } from \"scale-ts\"\nimport { compactNumber } from \"./compact\"\n\nexport interface BitSequence {\n  bitsLen: number\n  bytes: Uint8Array\n}\n\nconst bitSequenceDecoder: Decoder<BitSequence> = createDecoder((data) => {\n  const bitsLen = compactNumber.dec(data)\n\n  const bytesLen = Math.ceil(bitsLen / 8)\n  const bytes = Bytes(bytesLen).dec(data)\n  return { bytes, bitsLen }\n})\n\nconst bitSequenceEncoder: Encoder<BitSequence> = (input) => {\n  if (input.bitsLen > input.bytes.length * 8)\n    throw new Error(\n      `Not enough bytes. (bitsLen:${input.bitsLen}, bytesLen:${input.bytes.length})`,\n    )\n\n  const lenEncoded = compactNumber.enc(input.bitsLen)\n  const result = new Uint8Array(input.bytes.length + lenEncoded.length)\n  result.set(lenEncoded, 0)\n  result.set(input.bytes, lenEncoded.length)\n  return result\n}\n\nexport const bitSequence = createCodec(bitSequenceEncoder, bitSequenceDecoder)\n"],"names":[],"mappings":";;;AAQA,MAAM,kBAAA,GAA2C,aAAc,CAAA,CAAC,IAAS,KAAA;AACvE,EAAM,MAAA,OAAA,GAAU,aAAc,CAAA,GAAA,CAAI,IAAI,CAAA;AAEtC,EAAA,MAAM,QAAW,GAAA,IAAA,CAAK,IAAK,CAAA,OAAA,GAAU,CAAC,CAAA;AACtC,EAAA,MAAM,KAAQ,GAAA,KAAA,CAAM,QAAQ,CAAA,CAAE,IAAI,IAAI,CAAA;AACtC,EAAO,OAAA,EAAE,OAAO,OAAQ,EAAA;AAC1B,CAAC,CAAA;AAED,MAAM,kBAAA,GAA2C,CAAC,KAAU,KAAA;AAC1D,EAAA,IAAI,KAAM,CAAA,OAAA,GAAU,KAAM,CAAA,KAAA,CAAM,MAAS,GAAA,CAAA;AACvC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,8BAA8B,KAAM,CAAA,OAAO,CAAc,WAAA,EAAA,KAAA,CAAM,MAAM,MAAM,CAAA,CAAA;AAAA,KAC7E;AAEF,EAAA,MAAM,UAAa,GAAA,aAAA,CAAc,GAAI,CAAA,KAAA,CAAM,OAAO,CAAA;AAClD,EAAA,MAAM,SAAS,IAAI,UAAA,CAAW,MAAM,KAAM,CAAA,MAAA,GAAS,WAAW,MAAM,CAAA;AACpE,EAAO,MAAA,CAAA,GAAA,CAAI,YAAY,CAAC,CAAA;AACxB,EAAA,MAAA,CAAO,GAAI,CAAA,KAAA,CAAM,KAAO,EAAA,UAAA,CAAW,MAAM,CAAA;AACzC,EAAO,OAAA,MAAA;AACT,CAAA;AAEa,MAAA,WAAA,GAAc,WAAY,CAAA,kBAAA,EAAoB,kBAAkB;;;;"}