{"version":3,"file":"Binary.mjs","sources":["../../../../src/codecs/scale/Binary.ts"],"sourcesContent":["import {\n  Bytes,\n  Codec,\n  Decoder,\n  Encoder,\n  Tuple,\n  compact,\n  createCodec,\n} from \"scale-ts\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\nimport type { HexString } from \"./Hex\"\nimport { SS58String } from \"@/utils\"\nimport { AccountId } from \"./AccountId\"\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\nconst opaqueBytesDec = Tuple(compact, Bytes(Infinity))[1]\n\nexport class Binary {\n  #bytes: Uint8Array\n  #opaqueBytes: Uint8Array | null = null\n  #hex: HexString | null = null\n  #opaqueHex: HexString | null = null\n  #str: string | null = null\n\n  constructor(data: Uint8Array, opaque = false) {\n    if (opaque) {\n      try {\n        const [len, bytes] = opaqueBytesDec(data)\n        if (len === bytes.length) {\n          this.#bytes = bytes\n          this.#opaqueBytes = data\n          return\n        }\n      } catch (_) {}\n      throw new Error(\"Invalid opaque bytes\")\n    } else this.#bytes = data\n  }\n\n  asText = () => (this.#str ??= textDecoder.decode(this.#bytes))\n\n  asHex = () => (this.#hex ||= toHex(this.#bytes))\n  asOpaqueHex = () => (this.#opaqueHex ||= toHex(this.asBytes()))\n\n  asBytes = () => this.#bytes\n  asOpaqueBytes = () =>\n    (this.#opaqueBytes ||= mergeUint8([\n      this.#bytes,\n      compact[0](this.#bytes.length),\n    ]))\n\n  static fromText(input: string): Binary {\n    return new this(textEncoder.encode(input))\n  }\n\n  static fromHex(input: HexString): Binary {\n    return new this(fromHex(input))\n  }\n  static fromOpaqueHex(input: HexString): Binary {\n    return new this(fromHex(input), true)\n  }\n\n  static fromBytes(input: Uint8Array): Binary {\n    return new this(input)\n  }\n  static fromOpaqueBytes(input: Uint8Array): Binary {\n    return new this(input, true)\n  }\n}\n\nconst [accountIdEncoder] = AccountId()\nexport class FixedSizeBinary<_L extends number> extends Binary {\n  constructor(data: Uint8Array) {\n    super(data)\n  }\n\n  static fromArray<L extends number, I extends Array<number> & { length: L }>(\n    input: I,\n  ) {\n    return new this<L>(new Uint8Array(input))\n  }\n\n  static fromAccountId32<L extends number>(\n    input: L extends 32 ? SS58String : never,\n  ) {\n    return new this<L>(accountIdEncoder(input))\n  }\n}\n\nconst enc = (nBytes?: number): Encoder<Binary> => {\n  const _enc = Bytes.enc(nBytes)\n  return (value) => _enc(value.asBytes())\n}\n\nconst dec = (nBytes?: number): Decoder<Binary> => {\n  const _dec = Bytes.dec(nBytes)\n  const Bin = nBytes == null ? Binary : FixedSizeBinary\n  return (value) => Bin.fromBytes(_dec(value))\n}\n\nexport const Bin = (nBytes?: number): Codec<Binary> =>\n  createCodec(enc(nBytes), dec(nBytes))\n\nBin.enc = enc\nBin.dec = dec\n"],"names":["Bin"],"mappings":"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"}