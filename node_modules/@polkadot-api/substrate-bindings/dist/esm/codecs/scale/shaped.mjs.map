{"version":3,"file":"shaped.mjs","sources":["../../../../src/codecs/scale/shaped.ts"],"sourcesContent":["import {\n  Struct as OStruct,\n  Tuple as OTuple,\n  Vector as OVector,\n  Result as OResult,\n  Option as OOption,\n  Codec,\n  Encoder,\n  Decoder,\n  StringRecord,\n  CodecType,\n  EncoderType,\n  DecoderType,\n  ResultPayload,\n} from \"scale-ts\"\nimport { withInner } from \"./with-inner\"\n\nexport const Struct: {\n  <A extends StringRecord<Codec<any>>>(\n    codecs: A,\n  ): Codec<{ [K in keyof A]: CodecType<A[K]> }> & { inner: A }\n  enc: <A_1 extends StringRecord<Encoder<any>>>(\n    encoders: A_1,\n  ) => Encoder<{ [K_1 in keyof A_1]: EncoderType<A_1[K_1]> }> & { inner: A_1 }\n  dec: <A_2 extends StringRecord<Decoder<any>>>(\n    decoders: A_2,\n  ) => Decoder<{ [K_2 in keyof A_2]: DecoderType<A_2[K_2]> }> & { inner: A_2 }\n} = (codecs) => withInner(OStruct(codecs), codecs)\nStruct.enc = (x) => withInner(OStruct.enc(x), x)\nStruct.dec = (x) => withInner(OStruct.dec(x), x)\n\nexport const Tuple: {\n  <A extends Codec<any>[]>(\n    ...inner: A\n  ): Codec<{ [K in keyof A]: A[K] extends Codec<infer D> ? D : unknown }> & {\n    inner: A\n  }\n  enc: <A_1 extends Encoder<any>[]>(\n    ...encoders: A_1\n  ) => Encoder<{\n    [K_1 in keyof A_1]: A_1[K_1] extends Encoder<infer D_1> ? D_1 : unknown\n  }> & { inner: A_1 }\n  dec: <A_2 extends Decoder<any>[]>(\n    ...decoders: A_2\n  ) => Decoder<{\n    [K_2 in keyof A_2]: A_2[K_2] extends Decoder<infer D_2> ? D_2 : unknown\n  }> & { inner: A_2 }\n} = (...inner) => withInner(OTuple(...inner), inner)\nTuple.enc = (...inner) => withInner(OTuple.enc(...inner), inner)\nTuple.dec = (...inner) => withInner(OTuple.dec(...inner), inner)\n\nexport const Vector: {\n  <T>(\n    inner: Codec<T>,\n    size?: number | undefined,\n  ): Codec<T[]> & { inner: Codec<T> }\n  enc: <T_1>(\n    inner: Encoder<T_1>,\n    size?: number | undefined,\n  ) => Encoder<T_1[]> & { inner: Encoder<T_1> }\n  dec: <T_2>(\n    getter: Decoder<T_2>,\n    size?: number | undefined,\n  ) => Decoder<T_2[]> & { inner: Decoder<T_2> }\n} = (inner, ...rest) => withInner(OVector(inner, ...rest), inner)\nVector.enc = (inner, ...rest) => withInner(OVector.enc(inner, ...rest), inner)\nVector.dec = (inner, ...rest) => withInner(OVector.dec(inner, ...rest), inner)\n\nexport const Result: {\n  <OK, KO>(\n    okCodec: Codec<OK>,\n    koCodec: Codec<KO>,\n  ): Codec<ResultPayload<OK, KO>> & { inner: { ok: Codec<OK>; ko: Codec<KO> } }\n  dec: <OK_1, KO_1>(\n    okDecoder: Decoder<OK_1>,\n    koDecoder: Decoder<KO_1>,\n  ) => Decoder<ResultPayload<OK_1, KO_1>> & {\n    inner: { ok: Decoder<OK_1>; ko: Decoder<KO_1> }\n  }\n  enc: <OK_2, KO_2>(\n    okEncoder: Encoder<OK_2>,\n    koEncoder: Encoder<KO_2>,\n  ) => Encoder<ResultPayload<OK_2, KO_2>> & {\n    inner: { ok: Encoder<OK_2>; ko: Encoder<KO_2> }\n  }\n} = (ok, ko) => withInner(OResult(ok, ko), { ok, ko })\nResult.enc = (ok, ko) => withInner(OResult.enc(ok, ko), { ok, ko })\nResult.dec = (ok, ko) => withInner(OResult.dec(ok, ko), { ok, ko })\n\nexport const Option: {\n  <T>(inner: Codec<T>): Codec<T | undefined> & { inner: Codec<T> }\n  enc: <T_1>(\n    inner: Encoder<T_1>,\n  ) => Encoder<T_1 | undefined> & { inner: Encoder<T_1> }\n  dec: <T_2>(\n    inner: Decoder<T_2>,\n  ) => Decoder<T_2 | undefined> & { inner: Decoder<T_2> }\n} = (inner) => withInner(OOption(inner), inner)\nOption.enc = (inner) => withInner(OOption.enc(inner), inner)\nOption.dec = (inner) => withInner(OOption.dec(inner), inner)\n"],"names":["OStruct","OTuple","OVector","OResult","OOption"],"mappings":";;;AAiBO,MAAM,SAUT,CAAC,MAAA,KAAW,UAAUA,QAAQ,CAAA,MAAM,GAAG,MAAM;AACjD,MAAO,CAAA,GAAA,GAAM,CAAC,CAAM,KAAA,SAAA,CAAUA,SAAQ,GAAI,CAAA,CAAC,GAAG,CAAC,CAAA;AAC/C,MAAO,CAAA,GAAA,GAAM,CAAC,CAAM,KAAA,SAAA,CAAUA,SAAQ,GAAI,CAAA,CAAC,GAAG,CAAC,CAAA;AAElC,MAAA,KAAA,GAgBT,IAAI,KAAU,KAAA,SAAA,CAAUC,QAAO,GAAG,KAAK,GAAG,KAAK;AACnD,KAAM,CAAA,GAAA,GAAM,IAAI,KAAU,KAAA,SAAA,CAAUA,QAAO,GAAI,CAAA,GAAG,KAAK,CAAA,EAAG,KAAK,CAAA;AAC/D,KAAM,CAAA,GAAA,GAAM,IAAI,KAAU,KAAA,SAAA,CAAUA,QAAO,GAAI,CAAA,GAAG,KAAK,CAAA,EAAG,KAAK,CAAA;AAElD,MAAA,MAAA,GAaT,CAAC,KAAA,EAAA,GAAU,IAAS,KAAA,SAAA,CAAUC,SAAQ,KAAO,EAAA,GAAG,IAAI,CAAA,EAAG,KAAK;AAChE,MAAO,CAAA,GAAA,GAAM,CAAC,KAAA,EAAA,GAAU,IAAS,KAAA,SAAA,CAAUA,QAAQ,CAAA,GAAA,CAAI,KAAO,EAAA,GAAG,IAAI,CAAA,EAAG,KAAK,CAAA;AAC7E,MAAO,CAAA,GAAA,GAAM,CAAC,KAAA,EAAA,GAAU,IAAS,KAAA,SAAA,CAAUA,QAAQ,CAAA,GAAA,CAAI,KAAO,EAAA,GAAG,IAAI,CAAA,EAAG,KAAK,CAAA;AAEtE,MAAM,MAiBT,GAAA,CAAC,EAAI,EAAA,EAAA,KAAO,SAAU,CAAAC,QAAA,CAAQ,EAAI,EAAA,EAAE,CAAG,EAAA,EAAE,EAAI,EAAA,EAAA,EAAI;AACrD,MAAA,CAAO,GAAM,GAAA,CAAC,EAAI,EAAA,EAAA,KAAO,SAAU,CAAAA,QAAA,CAAQ,GAAI,CAAA,EAAA,EAAI,EAAE,CAAA,EAAG,EAAE,EAAA,EAAI,IAAI,CAAA;AAClE,MAAA,CAAO,GAAM,GAAA,CAAC,EAAI,EAAA,EAAA,KAAO,SAAU,CAAAA,QAAA,CAAQ,GAAI,CAAA,EAAA,EAAI,EAAE,CAAA,EAAG,EAAE,EAAA,EAAI,IAAI,CAAA;AAE3D,MAAM,SAQT,CAAC,KAAA,KAAU,UAAUC,QAAQ,CAAA,KAAK,GAAG,KAAK;AAC9C,MAAO,CAAA,GAAA,GAAM,CAAC,KAAU,KAAA,SAAA,CAAUA,SAAQ,GAAI,CAAA,KAAK,GAAG,KAAK,CAAA;AAC3D,MAAO,CAAA,GAAA,GAAM,CAAC,KAAU,KAAA,SAAA,CAAUA,SAAQ,GAAI,CAAA,KAAK,GAAG,KAAK,CAAA;;;;"}